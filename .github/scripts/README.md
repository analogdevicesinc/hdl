# Guidelines & files check scripts

These scripts are used for checking the integrity and correctness of the files across the HDL repository. The first script called **check_for_missing_readme_md.sh** is used to check the correctness of the README files only while the second script called **check_guideline.py** has the sole role of checking if our guidelines are implemented across the other files.

## User guide for [check_readme.sh](https://github.com/analogdevicesinc/hdl/blob/main/.github/scripts/check_readme.sh)

### Prerequisites

- The script must be run from the root of the HDL repository (e.g., `/hdl`);
- It assumes a directory structure like:
  - `projects/<board>/README.md`
  - `projects/<board>/<carrier>/README.md`
- It requires `bash` or `sh`, but it **does not** require any external dependencies.

### Purpose

This script ensures that all HDL project directories contain properly formatted `README.md` files and that they follow documentation conventions.

### Rules that are checked

#### 1. Presence of README files

- Each board directory (e.g., `projects/adrv9009zu11eg/`) must contain a `README.md`;
- Each carrier subdirectory (e.g., `projects/adrv9009zu11eg/zcu102/`) must also contain a `README.md`.

#### 2. Title format

- The main board README must have a title in the format: `<BOARD-NAME> HDL Project`.
  Example: `# ADRV9009ZU11EG HDL Project`;
- Carrier README titles must follow the format: `<BOARD-NAME>/<CARRIER-NAME> HDL Project`
  Example: `ADRV9009ZU11EG/ZCU102 HDL Project`;
- **Board names** are uppercased and underscores are replaced with hyphens (e.g., `ad9081_fmca_ebz` → `AD9081-FMCA-EBZ`);
- **Carrier names** are uppercased as-is (e.g., `de10nano` → `DE10NANO`), except for special carriers.

#### 3. Special carrier exceptions

The following carriers are allowed to use underscore in their README titles and are not flagged for title mismatches:

- `ccbob_*`
- `ccfmc_*`
- `ccpackrf_*`
- `adrv2crr_fmc`
- `adrv2crr_fmcomms8`
- `adrv2crr_fmcxmwbr1`

Based on the case, you can add special carriers by modifying the script.

```sh
# Function to detect special carriers (e.g., ccbob_cmos, ccfmc_lvds)
is_special_carrier() {
    case "$1" in
        ccbob_*|ccfmc_*|ccpackrf_*|adrv2crr_fmc|adrv2crr_fmcomms8|adrv2crr_fmcxmwbr1)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}
```

#### 4. Required sections

- **Main board README** MUST contain:
  - `Building the project`
  - `Supported parts`
- **Carrier README** SHOULD contain all the below sub-sections*:
  - `Building the project`
  - `Example configurations`
  - A mention of a **default configuration** under the `Example configurations` section

```
* If it's not possible, you MUST include the following flags, depedinding on your case (on what sub-section cannot be included):
  - no_build_example: this project doesn't have the Example configurations section, so it doesn't have build parameters
  - no_dts: this project doesn't have a device tree associated
  - no_no_os: this project doesn't have a no-OS project associated

Include these flags on the first line of the README.md file, as a MarkDown comment, like this (depeding on what you can't include):

<!-- no_build_example, no_dts, no_no_os -->
```

#### 5. Forbidden content

- Links to the following are not allowed:
  - `https://wiki.analog.com/resources/tools-software/linux-drivers-all`
  - `https://wiki.analog.com/linux`
- Empty Markdown links like `` or `([ ])` are flagged.

### Output

The script prints a summary for each board and carrier, indicating:

- ✔ if the README is valid
- ✖ if there are issues, with a description of what’s missing or incorrect

At the end, if any issues are found, it prints: **Something occurred! Check the output of the script.**

### Example of running

```sh
cd hdl/
source .github/scripts/check_for_missing_readme_md.sh
```

---

## User guide for [check_guideline.py](https://github.com/analogdevicesinc/hdl/tree/main/.github/scripts/check_guideline.py)

### Prerequisites

* the script must be run while being in the root directory (/hdl)
* clean the repository to remove the files generated by Vivado
* runs on Verilog (.v) and SystemVerilog (.sv) files, except those containing
"tb" in their path/name (testbenches are ignored)
* uses Python 3.x

### Rules that are checked

These rules can be found in the [HDL coding guidelines](https://analogdevicesinc.github.io/hdl/user_guide/hdl_coding_guidelines.html).

#### 1. License header

It checks that the copyright years after Copyright (C) are up-to-date and properly
formatted.
Supported forms: a single year, a range (YYYY-YYYY), or a comma-separated list
combining singles and/or ranges. 
Exceptions are the JESD files and the ones specified in the `avoid_list` string list.

The following checks are performed (only the last year and, if present, the
penultimate year are considered):
 * If the last year equals the current year:
   * If a penultimate year exists and current - penultimate == 1, it must be a range (-).
   * If it is written as a list (, current), the script warns and merges to ...-current.
   * If a penultimate year exists and current - penultimate > 1, a list is correct; only formatting may be normalized.
   * If there is no penultimate year, a single current year is OK.
 * If the last year is not the current year:
   * If current - last == 1, it extends the last token into a range ending at the current year.
   * If current - last > 1, it appends , current.

Examples:
```
2013-2024          -> 2013-2025
2013-2020          -> 2013-2020, 2025
2024               -> 2024-2025
2022               -> 2022, 2025
2013, 2024         -> 2013, 2024-2025
2013-2024, 2025    -> 2013-2025        (warn: wrong delimiter; merged)
2013-2020, 2025    -> 2013-2020, 2025  (ok as list; spacing normalized)
```

If `-e` option is added, the script can update the year range.

#### 2. Empty lines

It checks if the file contains empty line issues:
* Two or more consecutive empty lines.
* An empty line at the beginning of the file.
* An empty line at the end of the file.

If `-e` option is added, the script removes redundant empty lines and ensures
that at most one empty line is kept, while also removing any leading or trailing
empty lines.

#### 3. Trailing whitespace

It checks if there are whitespace characters at the end of the lines.

If `-e` option is added, then they can be removed.

#### 4. Lines after end token

It checks if there are lines after end token (`endmodule` or `endpackage`).

If `-e` option is added, the script can remove them.

#### 5. Parentheses around the module declaration

It checks if the parentheses around the module declaration (meaning `) (` for
the parameters' list) are on an empty line, right after the last parameter.
It also checks for the closing parenthesis at the module declaration (meaning `);`)
to be on an empty line, at the beginning, right after the last I/O port line.

If `-e` option is added, the script can put them in their proper place.

#### 6. Indentation of code

It checks that indentation is done with spaces in multiples of 2 (minimum 2).
This applies to parameters, ports, and code inside modules or packages.

#### 7. Position of the module instances

It checks if the parameters' list (if that's the case) is in proper position,
meaning that the position of `#` is checked, the parameters to be specified each
on its own line, the parentheses around the instance name and the closing
parenthesis of the module instance.

_NOTE_: these rules are marked in the script with **GC** (stands for Guideline Check)
in the comments.

#### 8. SystemVerilog packages

It checks if SystemVerilog packages are defined correctly:
* `package <name>;` starts at column 0, with no extra spaces before or after ;.
* `endpackage` is alone on its line at column 0.
* Exactly one newline follows `endpackage`.
* Inside the package, typedefs and localparams follow the same indentation and alignment rules.

If `-e` option is added, the script rewrites these to the guideline-compliant
format.

#### 9. Localparams

It checks if localparam declarations follow the rules:
* Indented by a multiple of 2 spaces (minimum 2).
* **List form:** each item is on a new line, `=` operator is aligned, and the last
item has no comma.
* **Concatenation form ({ … }):**
  * The first element is on the same line as `{`.
  * Following elements are indented +2 spaces.
  * Inline comments are aligned at least 4 spaces after the longest element.
  * The closing `};` is attached to the last element.

If `-e` option is added, the script normalizes the block automatically.

#### 10. Typedefs

It checks if typedef blocks are formatted correctly:
* They are not written as one-liners, each item is on its own line.
* Base indentation is a multiple of 2 and at least 2.
* Inner items are indented +2.
* Closing `} type_name;` is aligned with the opening `typedef`.
* Inline comments after the closing are moved to a separate line.

If `-e` option is added, the script rewrites the block to the guideline-compliant
format.

#### 11. Project name vs. path

It checks that in each system_project.tcl, the project name used in `adi_project`
matches the relative project path under `projects/`.

Example:
```
projects/ad9783_ebz/zcu102 ⇒ adi_project ad9783_ebz_zcu102
```

If `-e` option is added, the script updates the project name automatically.

### Changes done by the script to your files

If edits are enabled (-e), the script may modify:
* license header, except for files specified in `avoid_list`
* empty lines (two or more consecutive, or at file start/end)
* trailing whitespaces
* lines after `endmodule`/`endpackage` tag
* parentheses around the module declaration (meaning `) (` for the parameters'
  list and `);` for when closing the declaration)
* typedefs and localparams — rewritten into a guideline-compliant format
* SystemVerilog packages — normalizes `package <name>;` / `endpackage` placement
and ensures exactly one newline after `endpackage`
* project name inside `system_project.tcl` (to match the relative project path)

### Ways to run the script

The script supports several modes of execution, depending on what files you want
to check and whether edits are allowed:

1. With no arguments: `python3 check_guideline.py`
Runs on all HDL files under `library/` and `projects/`, in check-only mode (does
not modify the files).

2. With arguments:
  1. `-e` with no file specified: `python3 check_guideline.py -e`
    Checks all files with the properties specified above and applies fixes
    according to the guideline.

  2. `-m`
    Checks files that are given as arguments (by their names including the
    extension).

  3. `-me`
    Checks files that are given as arguments (by their names including the
    extension) and modifies the files where the guideline is not respected.

  4. `-p`
    Checks files that are given as arguments (by their relative path) and
    modifies the files where the guideline is not respected.

  5. `-pe`
    Checks files that are given as arguments (by their relative path) and
    modifies the files where the guideline is not respected.

### Examples of running

```
# Check all files in the repo, no modifications
python3 check_guideline.py     >> warnings.txt

# Check and edit every HDL file in the repo
python3 check_guideline.py -e  >> warnings.txt

# Check a specific file given by name, no modifications
python3 check_guideline.py -m  axi_ad9783.v >> warnings.txt

# Check and edit a specific files by name
python3 check_guideline.py -me axi_ad9783.v axi_ad9783_if.v up_adc_common.v >> warnings.txt

# Check specific files given by absolute/relative paths, no modifications
python3 check_guideline.py -p  ./library/axi_ad9783/axi_ad9783.v ./library/common/up_adc_common.v >> warnings.txt

# Check and edit a specific file given by absolute/relative path
python3 check_guideline.py -pe ./library/axi_ad9783/axi_ad9783_if.v >> warnings.txt
```
